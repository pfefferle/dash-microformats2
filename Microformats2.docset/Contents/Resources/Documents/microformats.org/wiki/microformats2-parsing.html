<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from microformats.org/wiki/microformats2-parsing by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 22 Jun 2016 19:41:09 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

	<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
	
	<meta content="MediaWiki 1.13.2" name="generator"/>
		<meta content="microformats2-parsing,IRC,microformats2,microformats2-implied-properties,microformats2-parsing-brainstorming,microformats2-parsing-faq,microformats2-parsing-issues,microformats2-parsing-rdf,value-class-pattern,Tantek" name="keywords"/>
		
		
		
		
	<link href="skins/common/shared.css" rel="stylesheet" type="text/css"/>		
	<link href="skins/Microformats/microformats.css" rel="stylesheet" type="text/css"/>

	


    
    		


        
        	
	<title>microformats2 parsing specification · Microformats Wiki</title>
	
<style id="dash-style" type="text/css">.content { width: 100%; }</style></head>
	<!-- TODO: Template-dervied body class: spec and draft -->
<body class="page-microformats2-parsing specification draft">
    
    

    <div class="content hentry">
    
	

	    <h1 class="entry-title">microformats2 parsing specification</h1>

		<p class="sub-title"></p>

								    <!-- TODO: Jump nav -->
		    <div id="jump-to-nav">Jump to:		        <a href="#sidebar">navigation</a>, 
		        <a href="#search">search</a>
		    </div>
		        
        <div class="entry-content">
		<p><dfn style="font-style:normal;font-weight:bold"><a href="microformats2.html" title="microformats2">microformats2</a></dfn> is a simple, open format for marking up data in HTML. The microformats2 parsing specification describes how to <a href="#implementations" title="">implement</a> a microformats2 parser, independent of any specific vocabularies.
</p>
<dl><dt>Status
</dt><dd>This is a <b>Living Specification</b> with several interoperable <a href="#implementations" title="">implementations</a>
</dd><dt>Participate
</dt><dd><a class="external text" href="https://github.com/microformats/microformats2-parsing/issues" rel="nofollow" title="https://github.com/microformats/microformats2-parsing/issues">Open Issues</a>
</dd><dd><a href="microformats2-parsing-issues.html" title="microformats2-parsing-issues">Resolved issues before 2016-06-20</a>
</dd><dd><a class="mw-redirect" href="http://microformats.org/wiki/IRC" title="IRC">IRC</a>: <a class="external text" href="irc://irc.freenode.net/microformats" rel="nofollow" title="irc://irc.freenode.net/microformats">#microformats on Freenode</a>
</dd></dl>
<div class="p-author h-card vcard">
<dl><dt><span class="p-role role">Editor</span>
</dt><dd><span class="p-name fn"><a href="http://microformats.org/wiki/User:Tantek" title="User:Tantek">Tantek Çelik</a></span>
</dd></dl>
</div>
<dl><dt>License
</dt><dd> <small>Per <a class="external text" href="http://creativecommons.org/publicdomain/zero/1.0/" rel="nofollow" title="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a>, to the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work. In addition, as of 2016-06-22, the editors have made this specification available under the <a class="external text" href="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0" rel="nofollow" title="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0">Open Web Foundation Agreement Version 1.0</a>.</small>
</dd></dl>

<a name="algorithm"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/algorithm"></a> algorithm </span></h2>
<a name="parse_a_document_for_microformats"></a><h3> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parse%20a%20document%20for%20microformats"></a> parse a document for microformats </span></h3>
<p>To parse a document for microformats, follow the HTML parsing rules and do the following:
</p>
<ul><li> start with an empty JSON "items" array and "rels" &amp; "rel-urls" hashes: 
</li></ul>
<div dir="ltr" style="text-align: left;"><pre class="source-javascript"><span class="br0">{</span>
 <span class="st0">"items"</span><span class="sy0">:</span> <span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span>
 <span class="st0">"rels"</span><span class="sy0">:</span> <span class="br0">{</span><span class="br0">}</span><span class="sy0">,</span>
 <span class="st0">"rel-urls"</span><span class="sy0">:</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span></pre></div>
<ul><li> parse the root element for class microformats, adding to the JSON items array accordingly
</li><li> parse all hyperlink (<code>&lt;a&gt; &lt;area&gt; &lt;link&gt;</code>) elements for rel microformats, adding to the JSON rels &amp; rel-urls hashes accordingly
</li><li> return the resulting JSON
</li></ul>
<p>Parsers may simultaneously parse the document for both class and rel microformats (e.g. in a single tree traversal).
</p>
<a name="parse_an_element_for_class_microformats"></a><h3> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parse%20an%20element%20for%20class%20microformats"></a> parse an element for class microformats </span></h3>
<p>To parse an element for class microformats:
</p>
<ul><li> parse element class for root class name(s) "h-*" and if none, backcompat root classes
<ul><li> if none found, parse child elements for microformats (depth first, doc order)
</li><li> else if found, start parsing a new microformat
<ul><li> keep track of whether the root class name(s) was from backcompat
</li><li> create a new { } structure with:
<ul><li> <code>type: [array of microformat "h-*" type(s) on the element],</code>
</li><li> <code>properties: { } </code> - to be filled in when that element itself is parsed for microformats properties
</li></ul>
</li><li> parse child elements (document order) by:
<ul><li> if parsing a backcompat root, parse child element class name(s) for backcompat properties
</li><li> else parse a child element class for property class name(s) "p-*,u-*,dt-*,e-*"
</li><li> if such class(es) are found, it is a property element
<ul><li> add properties found to current microformat's <code>properties: { } </code> structure
</li></ul>
</li><li> parse a child element for microformats (recurse)
<ul><li> if that child element itself has a microformat ("h-*" or backcompat roots) and is a property element, add it into the array of values for that property as a { } structure, add to that { } structure:
<ul><li> <code>value</code>: 
<ul><li> if it's a <code>p-*</code> property element, use the first p-name of the h-* child 
</li><li> else if it's an <code>e-*</code> property element, re-use its { } structure with existing <code>value:</code> inside.
</li><li> else if it's a <code>u-*</code> property element and the h-* child has a u-url, use the first such u-url
</li><li> else use the parsed property value per p-*,u-*,dt-* parsing respectively
</li></ul>
</li></ul>
</li><li> else add found elements that are microformats to the "children" array
</li></ul>
</li></ul>
</li><li> imply properties for the found microformat (see below)
</li></ul>
</li></ul>
</li></ul>
<p>The "*" for root (and property) class names consists only of lowercase a-z and '-' characters.
</p>
<a name="parse_an_element_for_properties"></a><h3> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parse%20an%20element%20for%20properties"></a> parse an element for properties </span></h3>
<a name="parsing_a_p-_property"></a><h4> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parsing%20a%20p-%20property"></a> parsing a p- property </span></h4>
<p>To parse an element for a p-x property value whether explicit "p-*" or backcompat equivalent:
</p>
<ul><li> parse the element for the <a href="http://microformats.org/wiki/value-class-pattern" title="value-class-pattern">value-class-pattern</a>, if a value is found then return it.
</li><li> if abbr.p-x[title], then return the title attribute
</li><li> else if data.p-x[value] or input.p-x[value], then return the value attribute
</li><li> else if img.p-x[alt] or area.p-x[alt], then return the alt attribute
</li><li> else return the textContent of the element, replacing any nested <code>&lt;img&gt;</code> elements with their <code>alt</code> attribute if present, or otherwise their <code>src</code> attribute if present adding a space at the beginning and end, resolving any relative URLs, and removing all leading/trailing whitespace.
</li></ul>
<a name="parsing_a_u-_property"></a><h4> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parsing%20a%20u-%20property"></a> parsing a u- property </span></h4>
<p>To parse an element for a u-x property value whether explicit "u-*" or backcompat equivalent:
</p>
<ul><li> if a.u-x[href] or area.u-x[href], then get the href attribute
</li><li> else if img.u-x[src] or audio.u-x[src] or video.u-x[src] or source.u-x[src], then get the src attribute
</li><li> else if object.u-x[data], then get the data attribute
</li><li> <a href="microformats2-parsing-issues.html#use_poster_if_no_src_on_video_for_u_props" title="microformats2-parsing-issues">PROPOSED 2015-12-13</a>: else if video.u-x[poster], then get the poster attribute
</li><li> if there is a gotten value, return the normalized absolute URL of it, following the containing document's language's rules for resolving relative URLs (e.g. in HTML, use the current URL context as determined by the page, and first <code>&lt;base&gt;</code> element if any).
</li><li> else parse the element for the <a href="http://microformats.org/wiki/value-class-pattern" title="value-class-pattern">value-class-pattern</a>, if a value is found then return it.
</li><li> else if abbr.u-x[title], then return the title attribute
</li><li> else if data.u-x[value] or input.u-x[value], then return the value attribute
</li><li> else return the textContent of the element after removing all leading/trailing whitespace.
</li></ul>
<a name="parsing_a_dt-_property"></a><h4> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parsing%20a%20dt-%20property"></a> parsing a dt- property </span></h4>
<p>To parse an element for a dt-x property value whether explicit "dt-*" or backcompat equivalent:
</p>
<ul><li> parse the element for the <a href="http://microformats.org/wiki/value-class-pattern" title="value-class-pattern">value-class-pattern</a> including the date and time parsing rules, if a value is found then return it.
</li><li> if time.dt-x[datetime] or ins.dt-x[datetime] or del.dt-x[datetime], then return the datetime attribute
</li><li> else if abbr.dt-x[title], then return the title attribute
</li><li> else if data.dt-x[value] or input.dt-x[value], then return the value attribute
</li><li> else return the textContent of the element after removing all leading/trailing whitespace.
</li></ul>
<a name="parsing_an_e-_property"></a><h4> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parsing%20an%20e-%20property"></a> parsing an e- property </span></h4>
<p>To parse an element for a e-x property value whether explicit "e-*" or backcompat equivalent:
</p>
<ul><li> return a dictionary with two keys:
<ul><li> <code>html</code>: the innerHTML of the element by using the <a class="external text" href="https://html.spec.whatwg.org/multipage/syntax.html#serialising-html-fragments" rel="nofollow" title="https://html.spec.whatwg.org/multipage/syntax.html#serialising-html-fragments">HTML spec: Serializing HTML Fragments algorithm</a>, with leading/trailing whitespace removed.
</li><li> <code>value</code>: the textContent of the element, replacing any nested <code>&lt;img&gt;</code> elements with their <code>alt</code> attribute if present, or otherwise their <code>src</code> attribute if present, resolving the URL if it’s relative.
</li></ul>
</li></ul>
<a name="parsing_for_implied_properties"></a><h4> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parsing%20for%20implied%20properties"></a> parsing for implied properties </span></h4>
<p>Imply properties only on explicit h-x class name root microformat element (no backcompat roots)
</p>
<ul><li> if no explicit "name" property, 
</li><li> then imply by:
<ul><li> if img.h-x or area.h-x, then use its alt attribute for name
</li><li> else if abbr.h-x[title] then use its title attribute for name
</li><li> else if .h-x&gt;img:only-child[alt]:not([alt=""]):not[.h-*] then use that img alt for name
</li><li> else if .h-x&gt;area:only-child[alt]:not([alt=""]):not[.h-*] then use that area alt for name
</li><li> else if .h-x&gt;abbr:only-child[title]:not([title=""]):not[.h-*] then use that abbr title for name
</li><li> else if .h-x&gt;:only-child:not[.h-*]&gt;img:only-child[alt]:not([alt=""]):not[.h-*] then use that img alt for name
</li><li> else if .h-x&gt;:only-child:not[.h-*]&gt;area:only-child[alt]:not([alt=""]):not[.h-*] then use that area alt for name
</li><li> else if .h-x&gt;:only-child:not[.h-*]&gt;abbr:only-child[title]:not([title=""]):not[.h-*] use that abbr title for name
</li><li> else use the textContent of the .h-x for name
</li><li> drop all leading and trailing white-space from name
</li></ul>
</li><li> if no explicit "photo" property, 
</li><li> then imply by:
<ul><li> if img.h-x[src] then use src for photo
</li><li> else if object.h-x[data] then use data for photo
</li><li> else if .h-x&gt;img[src]:only-of-type:not[.h-*] then use that img src for photo
</li><li> else if .h-x&gt;object[data]:only-of-type:not[.h-*] then use that object data for photo
</li><li> else if .h-x&gt;:only-child:not[.h-*]&gt;img[src]:only-of-type:not[.h-*] then use that img src for photo
</li><li> else if .h-x&gt;:only-child:not[.h-*]&gt;object[data]:only-of-type:not[.h-*] then use that object data for photo
</li><li> if there is a gotten photo value, return the normalized absolute URL of it, following the containing document's language's rules for resolving relative URLs (e.g. in HTML, use the current URL context as determined by the page, and first &lt;base&gt; element if any).
</li></ul>
</li><li> if no explicit "url" property,
</li><li> then imply by:
<ul><li> if a.h-x[href] or area.h-x[href] then use that [href] for url
</li><li> else if .h-x&gt;a[href]:only-of-type:not[.h-*] then use that [href] for url
</li><li> else if .h-x&gt;area[href]:only-of-type:not[.h-*] then use that [href] for url
</li><li> else if .h-x&gt;:only-child:not[.h-*]&gt;a[href]:only-of-type:not[.h-*] then use that [href] for url
</li><li> else if .h-x&gt;:only-child:not[.h-*]&gt;area[href]:only-of-type:not[.h-*] then use that [href] for url
</li><li> if there is a gotten url value, return the normalized absolute URL of it, following the containing document's language's rules for resolving relative URLs (e.g. in HTML, use the current URL context as determined by the page, and first &lt;base&gt; element if any).
</li></ul>
</li></ul>
<p>Note: The same markup for a property should not be causing that property to occur in <em>both</em> a microformat and one embedded inside - such a property should only be showing up on one of them. The parsing algorithm has details to prevent that, such as the <code>:not[.h-*]</code> tests above.
</p>
<a name="parse_a_hyperlink_element_for_rel_microformats"></a><h3> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/parse%20a%20hyperlink%20element%20for%20rel%20microformats"></a> parse a hyperlink element for rel microformats </span></h3>
<p>To parse a hyperlink element (e.g. a or link) for rel microformats: use the following algorithm or an algorithm that produces equivalent results:
</p>
<ul><li> if the "rel" attribute of the element is empty then exit
</li><li> set url to the value of the "href" attribute of the element, normalized to be an absolute URL following the containing document's language's rules for resolving relative URLs (e.g. in HTML, use the current URL context as determined by the page, and first <code>&lt;base&gt;</code> element if any).
</li><li> treat the "rel" attribute of the element as a space separate set of rel values
</li><li> for each rel value (rel-value)
<ul><li> if there is no key rel-value in the rels hash then create it with an empty array as its value
</li><li> if url is not in the array of the key rel-value in the rels hash then add url to the array
</li></ul>
</li><li> end for
</li><li> if there is no key with name url in the top-level "rel-urls" hash then add a key with name url there, with an empty hash value
</li><li> add keys to the hash of the key with name url for each of these attributes (if present) and key not already set:
<ul><li> "hreflang": the value of the "hreflang" attribute
</li><li> "media": the value of the "media" attribute
</li><li> "title": the value of the "title" attribute
</li><li> "type": the value of the "type" attribute
</li><li> "text": the text content of the element if any
</li></ul>
</li><li> if there is no "rels" key in that hash, add it with an empty array value
</li><li> set the value of that "rels" key to an array of all unique items in the set of rel values unioned with the current array value of the "rels" key
</li></ul>
<a name="rel_parse_examples"></a><h4> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/rel%20parse%20examples"></a> rel parse examples </span></h4>
<p>Here are some examples to show how parsed rels may be reflected into the JSON (empty items key).
</p><p>E.g. parsing this markup:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-xml"><span class="re1">&lt;a</span> <span class="re0">rel</span>=<span class="st0">"author"</span> <span class="re0">href</span>=<span class="st0">"http://example.com/a"</span><span class="re2">&gt;</span><span class="co3">author a</span><span class="re1">&lt;/a<span class="re2">&gt;</span></span>
<span class="re1">&lt;a</span> <span class="re0">rel</span>=<span class="st0">"author"</span> <span class="re0">href</span>=<span class="st0">"http://example.com/b"</span><span class="re2">&gt;</span><span class="co3">author b</span><span class="re1">&lt;/a<span class="re2">&gt;</span></span>
<span class="re1">&lt;a</span> <span class="re0">rel</span>=<span class="st0">"in-reply-to"</span> <span class="re0">href</span>=<span class="st0">"http://example.com/1"</span><span class="re2">&gt;</span><span class="co3">post 1</span><span class="re1">&lt;/a<span class="re2">&gt;</span></span>
<span class="re1">&lt;a</span> <span class="re0">rel</span>=<span class="st0">"in-reply-to"</span> <span class="re0">href</span>=<span class="st0">"http://example.com/2"</span><span class="re2">&gt;</span><span class="co3">post 2</span><span class="re1">&lt;/a<span class="re2">&gt;</span></span>
<span class="re1">&lt;a</span> <span class="re0">rel</span>=<span class="st0">"alternate home"</span>
   <span class="re0">href</span>=<span class="st0">"http://example.com/fr"</span>
   <span class="re0">media</span>=<span class="st0">"handheld"</span>
   <span class="re0">hreflang</span>=<span class="st0">"fr"</span><span class="re2">&gt;</span><span class="co3">French mobile homepage</span><span class="re1">&lt;/a<span class="re2">&gt;</span></span></pre></div>
<p>Would generate this JSON:
</p>
<div dir="ltr" style="text-align: left;"><pre class="source-javascript"><span class="br0">{</span>
  <span class="st0">"items"</span><span class="sy0">:</span> <span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span>
  <span class="st0">"rels"</span><span class="sy0">:</span> <span class="br0">{</span> 
    <span class="st0">"author"</span><span class="sy0">:</span> <span class="br0">[</span> <span class="st0">"http://example.com/a"</span><span class="sy0">,</span> <span class="st0">"http://example.com/b"</span> <span class="br0">]</span><span class="sy0">,</span>
    <span class="st0">"in-reply-to"</span><span class="sy0">:</span> <span class="br0">[</span> <span class="st0">"http://example.com/1"</span><span class="sy0">,</span> <span class="st0">"http://example.com/2"</span> <span class="br0">]</span><span class="sy0">,</span>
    <span class="st0">"alternate"</span><span class="sy0">:</span> <span class="br0">[</span> <span class="st0">"http://example.com/fr"</span> <span class="br0">]</span><span class="sy0">,</span> 
    <span class="st0">"home"</span><span class="sy0">:</span> <span class="br0">[</span> <span class="st0">"http://example.com/fr"</span> <span class="br0">]</span> 
  <span class="br0">}</span><span class="sy0">,</span>
  <span class="st0">"rel-urls"</span><span class="sy0">:</span> <span class="br0">{</span>
    <span class="st0">"http://example.com/a"</span><span class="sy0">:</span> <span class="br0">{</span>
      <span class="st0">"rels"</span><span class="sy0">:</span> <span class="br0">[</span><span class="st0">"author"</span><span class="br0">]</span><span class="sy0">,</span> 
      <span class="st0">"text"</span><span class="sy0">:</span> <span class="st0">"author a"</span>
    <span class="br0">}</span><span class="sy0">,</span>
    <span class="st0">"http://example.com/b"</span><span class="sy0">:</span> <span class="br0">{</span>
      <span class="st0">"rels"</span><span class="sy0">:</span> <span class="br0">[</span><span class="st0">"author"</span><span class="br0">]</span><span class="sy0">,</span> 
      <span class="st0">"text"</span><span class="sy0">:</span> <span class="st0">"author b"</span>
    <span class="br0">}</span><span class="sy0">,</span>
    <span class="st0">"http://example.com/1"</span><span class="sy0">:</span> <span class="br0">{</span>
      <span class="st0">"rels"</span><span class="sy0">:</span> <span class="br0">[</span><span class="st0">"in-reply-to"</span><span class="br0">]</span><span class="sy0">,</span> 
      <span class="st0">"text"</span><span class="sy0">:</span> <span class="st0">"post 1"</span>
    <span class="br0">}</span><span class="sy0">,</span>
    <span class="st0">"http://example.com/2"</span><span class="sy0">:</span> <span class="br0">{</span>
      <span class="st0">"rels"</span><span class="sy0">:</span> <span class="br0">[</span><span class="st0">"in-reply-to"</span><span class="br0">]</span><span class="sy0">,</span> 
      <span class="st0">"text"</span><span class="sy0">:</span> <span class="st0">"post 2"</span>
    <span class="br0">}</span><span class="sy0">,</span>
    <span class="st0">"http://example.com/fr"</span><span class="sy0">:</span> <span class="br0">{</span>
      <span class="st0">"rels"</span><span class="sy0">:</span> <span class="br0">[</span><span class="st0">"alternate"</span><span class="sy0">,</span> <span class="st0">"home"</span><span class="br0">]</span><span class="sy0">,</span>
      <span class="st0">"media"</span><span class="sy0">:</span> <span class="st0">"handheld"</span><span class="sy0">,</span> 
      <span class="st0">"hreflang"</span><span class="sy0">:</span> <span class="st0">"fr"</span><span class="sy0">,</span> 
      <span class="st0">"text"</span><span class="sy0">:</span> <span class="st0">"French mobile homepage"</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div>
<p><br/>
</p>
<a name="what_do_the_CSS_selector_expressions_mean"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/what%20do%20the%20CSS%20selector%20expressions%20mean"></a> what do the CSS selector expressions mean </span></h2>
<p><i>This section is non-normative.</i>
</p><p>Use <a class="external text" href="http://gallery.theopalgroup.com/selectoracle/" rel="nofollow" title="http://gallery.theopalgroup.com/selectoracle/">SelectORacle</a> to expand any of the above CSS selector expressions into longform English prose.
</p><p>Exception:
</p>
<ul><li> <b>:not[.h-*]</b> is not a valid CSS selector but is used here to mean:
<ul><li> does not have any class names that start with "h-"
</li></ul>
</li></ul>
<a name="note_HTML_parsing_rules"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/note%20HTML%20parsing%20rules"></a> note HTML parsing rules </span></h2>
<p><i>This section is non-normative.</i>
</p><p>microformats2 parsers are expected to follow HTML parsing rules, which includes for example:
</p>
<ul><li> ignore <code>&lt;template&gt;</code> elements - stuff between <code>&lt;template&gt;</code> tags don't end up in the DOM
<ul><li> test-case in the wild: <a class="external free" href="http://sixtwothree.org/blog/now-accepting-webmentions/" rel="nofollow" title="http://sixtwothree.org/blog/now-accepting-webmentions/">http://sixtwothree.org/blog/now-accepting-webmentions/</a>
</li></ul>
</li></ul>
<a name="note_backward_compatibility_details"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/note%20backward%20compatibility%20details"></a> note backward compatibility details </span></h2>
<p>The parsing algorithm and details refer to "backcompat root classes" (backcompat roots for short) and "backcompat properties". These conditions and steps in the algorithm document how to parse pre-microformats2 microformats which all defined their own specific root class names and explicit sets of properties.
</p><p>Some details to be aware of (which are explicitly in the algorithm, this is just an informal summary)
</p>
<ul><li> If an element has one or more microformats2 root class name(s) (<code>h-*</code>) 
<ul><li> all backcompat root class names are ignored on that element.
</li><li> all backcompat properties, without an intervening root class name, are ignored inside that element
</li></ul>
</li><li> If an element has only a backcompat root class name (or names)
<ul><li> all microformats2 property class names (p-* u-* dt-* e-*), without an intervening element with root class name, are ignored inside that element
</li><li> there is no implied property value parsing (p-name, u-url, u-photo) for that element
</li></ul>
</li></ul>
<a name="backward_compatibility_mappings"></a><h3> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/backward%20compatibility%20mappings"></a> backward compatibility mappings </span></h3>
<p>Note: several parser implementations have encoded backward compatible mappings into source and data files. Implementers of parsers may find these useful:
</p>
<ul><li> search for "modules.maps[" in <a class="external free" href="https://github.com/glennjones/microformat-shiv/blob/master/microformat-shiv.js" rel="nofollow" title="https://github.com/glennjones/microformat-shiv/blob/master/microformat-shiv.js">https://github.com/glennjones/microformat-shiv/blob/master/microformat-shiv.js</a>
</li><li> search for "$classicPropertyMap" in <a class="external free" href="https://github.com/indieweb/php-mf2/blob/master/Mf2/Parser.php" rel="nofollow" title="https://github.com/indieweb/php-mf2/blob/master/Mf2/Parser.php">https://github.com/indieweb/php-mf2/blob/master/Mf2/Parser.php</a>
</li><li> <a class="external free" href="https://github.com/tommorris/mf2py/blob/master/mf2py/backcompat.py" rel="nofollow" title="https://github.com/tommorris/mf2py/blob/master/mf2py/backcompat.py">https://github.com/tommorris/mf2py/blob/master/mf2py/backcompat.py</a>
</li></ul>
<a name="questions"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/questions"></a> questions </span></h2>
<p>See the FAQ:
</p>
<ul><li> <a href="microformats2-parsing-faq.html" title="microformats2-parsing-faq">microformats2-parsing-faq</a>
</li></ul>
<a name="issues"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/issues"></a> issues </span></h2>
<p>See the issues page:
</p>
<ul><li> <a href="microformats2-parsing-issues.html" title="microformats2-parsing-issues">microformats2-parsing-issues</a>
</li></ul>
<a name="implementations"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/implementations"></a> implementations </span></h2>
<div style="text-indent:2em;font-style:italic">Main article: <a href="microformats2.html#Implementations" title="microformats2">microformats2#Implementations</a></div>
<p>There are open source <a href="microformats2.html#Implementations" title="microformats2">microformats2 parsers</a> available for Javascript, node.js, PHP, Ruby and Python.
</p>
<a name="test_suite"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/test%20suite"></a> test suite </span></h2>
<p>See:
</p>
<ul><li> <a class="external free" href="https://github.com/microformats/tests" rel="nofollow" title="https://github.com/microformats/tests">https://github.com/microformats/tests</a>
</li><li> <a class="external free" href="https://github.com/indieweb/php-mf2/tree/master/tests/Mf2" rel="nofollow" title="https://github.com/indieweb/php-mf2/tree/master/tests/Mf2">https://github.com/indieweb/php-mf2/tree/master/tests/Mf2</a>
</li></ul>
<p>Ports to/for other languages encouraged.
</p>
<a name="see_also"></a><h2> <span class="mw-headline"><a class="dashAnchor" name="//apple_ref/cpp/Section/see%20also"></a> see also </span></h2>
<ul><li> <a href="microformats2.html" title="microformats2">microformats2</a>
</li><li> <a href="microformats2-parsing-faq.html" title="microformats2-parsing-faq">microformats2-parsing-faq</a>
</li><li> <a href="microformats2-parsing-issues.html" title="microformats2-parsing-issues">microformats2-parsing-issues</a>
</li><li> <a href="microformats2-parsing-brainstorming.html" title="microformats2-parsing-brainstorming">microformats2-parsing-brainstorming</a> - for background, thinking, exploring possibilities
</li><li> <a href="microformats2-parsing-rdf.html" title="microformats2-parsing-rdf">microformats2-parsing-rdf</a>
</li><li> <a href="microformats2-implied-properties.html" title="microformats2-implied-properties">microformats2-implied-properties</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 78/1000000
Post-expand include size: 511/2097152 bytes
Template argument size: 29/2097152 bytes
Expensive parser function count: 0/100
-->
<div class="printfooter">
Retrieved from "<a href="microformats2-parsing.html">http://microformats.org/wiki/microformats2-parsing</a>"</div>
		</div>	
		
			        <h2>Categories</h2>
		    <div id="category-links">
		        <ul>
		        		            <li><a href="http://microformats.org/wiki/Category:Draft_Specifications" rel="tag">
		                Draft Specifications		            </a></li>
		        		        </ul>
		    </div>		        
				
                    
        
        

	</div>
	
<!-- end of the sidebar -->

<div id="footer">


    <address class="vcard">
        The content of this wiki is the combined effort of the
        <a class="fn org url" href="http://microformats.org/">
            microformats community
        </a>.
    </address>

	<ul>
    				<li id="about"><a href="http://microformats.org/wiki/Microformats_Wiki:About" title="Microformats Wiki:About">About Microformats Wiki</a></li>
				<li id="disclaimer"><a href="http://microformats.org/wiki/Microformats_Wiki:General_disclaimer" title="Microformats Wiki:General disclaimer">Disclaimers</a></li>
        <li>Powered by <a href="http://mediawiki.org/">MediaWiki</a> | <a href="http://mediatemple.net/">(mt) media temple</a></li>
	</ul>
</div>

		
<!-- Served in 0.371 secs. -->






</body><!-- Mirrored from microformats.org/wiki/microformats2-parsing by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 22 Jun 2016 19:41:10 GMT --></html>